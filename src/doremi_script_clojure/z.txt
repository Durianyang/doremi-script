(defn to-lilypond-new[composition]
  ;; Use state machine approach. New version
   {:pre [(= :composition (:my_type composition))] 
    :post [ (string? %) ]
  }
  ;;        (do (println "leaving new-collect-tied-notes, returns")
  ;;           (pprint %) true) 
  (if debug (do  (pprint composition)))
  (let [ 
        states [:in-line :looking-for-pitch]
        start-state :start
        my-state (atom start-state)
        current-beat-items (atom [])
        current-pitch (atom nil) 
        measure-length (atom nil)
        microbeat-counter (atom nil)
        beat-subdivisions (atom nil)
        last-pitch (atom nil)
        state-transition-function
        (fn state-transition-function[accumulator node]
          (let [
                my-type (cond (:is_barline node)
                              :barline
                              true
                              (:my_type node))
                pair [@my-state my-type]
                ]
            (if false (do
                        (print "reducing. type of node is")
                        (pprint my-type)))
            (if true (println "pair is" pair))
            (if (vector? node)
              accumulator
              ;; else
              (case pair
                [:collecting-pitch-in-beat :measure]
                (do (reset! my-state :collecting-pitch-in-beat-and-in-new-measure)
                    accumulator) 
                [:collecting-pitch-in-beat-and-in-new-measure :ignore]
                accumulator
                [:in-beat :pitch]
                (do
                  (reset! my-state :collecting-pitch-in-beat)
                  (reset! current-pitch node)  
                  (reset! microbeat-counter 1)  
                  (reset! beat-subdivisions 1)  
                  accumulator
                  )
                [:collecting-pitch-in-beat-and-in-new-measure :dash]
                (do 
                  (swap! microbeat-counter inc)
                  (swap! beat-subdivisions inc)
                  accumulator)
                [:in-measure :beat]
                (do 
                  (reset! my-state :in-beat)
                  (reset! current-beat-items [])
                    accumulator)
                [:in-line :measure]
                (do 
                  (reset!  measure-length 0)
                  (reset! my-state :in-measure)
                  accumulator)
                [:in-line :barline]
                (do (reset! my-state :in-line)
                    ;; (pprint node)
                    (conj accumulator (draw-barline node)))
                [:start :sargam_line]
                (do (reset! my-state :in-line)
                    accumulator)
                [:start :composition]
                accumulator
                [:collecting-pitch-in-beat :eof]
                (let [
                      
                      ] 
                  (println "@current-pitch is" @current-pitch)
                  (assoc @current-pitch :numerator @microbeat-counter)
                  (swap! current-beat-items conj @current-pitch)
                  (println "current-beat-items=" @current-beat-items)
                (new-draw-pitch (assoc @current-pitch
                                       :numerator @microbeat-counter 
                                       :denominator @beat-subdivisions)))
                [:looking-for-pitch :sargam_line]
                accumulator
                [:looking-for-pitch :measure]
                accumulator
                [:in-line :beat]
                accumulator
                [:collecting-pitch-in-beat :beat]
                accumulator
                [:looking-for-pitch :dash]
                accumulator
                [:collecting-pitch-in-beat :dash]
                (do (swap! microbeat-counter inc)
                   (swap! beat-subdivisions inc) 
                accumulator)
                [:looking-for-pitch :barline]
                accumulator
                [:looking-for-pitch :pitch]
                (do (reset! my-state :collecting-pitch-in-beat)
                    accumulator)
                [:collecting-pitch-in-beat :pitch]
                (let
                 [
                  updated-pitch (assoc @current-pitch
                                       :numerator @microbeat-counter 
                                       :denominator @beat-subdivisions)
                 ]
                  (reset! microbeat-counter 1)
                   (swap! beat-subdivisions inc) 
                  (reset! current-pitch node)
                (conj accumulator (new-draw-pitch updated-pitch))) 
                [:collecting-pitch-in-beat :barline]
                (do (reset! my-state :looking-for-pitch)
                    (pprint pair) accumulator)

                ;; (do (println "default case")
                ;;    accumulator)
              ))))
        ] 
    (str (join " " (reduce state-transition-function [] (my-seq composition)))
         " " (str (state-transition-function [] {:my_type :eof})))
    ))
