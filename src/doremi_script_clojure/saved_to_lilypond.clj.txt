(draw-pitch[pitch beat-subdivisions beam-start-or-end]
  { :pre [  (#{:pitch :dash}  (:my_type pitch)) 
            (integer? beat-subdivisions) 
            (contains? #{nil lilypond-beam-start lilypond-beam-end}
                       beam-start-or-end)
          ]
    :post [ (string? %)] 
   }
  "Render a pitch/dash as lilypond text. Renders tied notes as needed"
  ;; "Rests are never tied"
  ;; Use fraction-array to draw the tied notes
  ;; In draw-pitch for the Sa in the following:  
  ;; -S -- -- -R
  (if false (do
             (println "entering draw-pitch")
  (pprint pitch)))
  (cond (:ignore pitch)
        ""
        (and (= :dash (:my_type pitch))
             (not (:rest pitch)))
        ""
        true
        (let
          [ 
           debug true ;;(= 1 (:start_index pitch)) 
           _ (if debug (pprint pitch))
           ornament (get-ornament pitch)
           placement (:placement ornament)
           has-after-ornament (= :after placement)
           has-before-ornament (= :before placement)    
           begin-slur (if (get-attribute pitch :begin_slur) "(" )
           lilypond-octave  (octave-number->lilypond-octave (:octave pitch))

           combined-fraction-array 
           (combine-whole-notes-in-fraction-array (:fraction_array pitch))
           _ (if debug (do 
                         (println "combined fraction array:")
           (pprint combined-fraction-array)))
           needs-tie (> (count combined-fraction-array) 1)
           _ (if debug (println "needs-tie" needs-tie))
           durations-for-first-note 
             (ratio-to-lilypond 
               (:numerator (first combined-fraction-array)) 
               (:denominator (first combined-fraction-array)))
           _ (if debug (do
                         (println "durations-for-first-note:" durations-for-first-note)
           (println)
           (println "before setting durations2")
           (pprint combined-fraction-array)
                         ))
           durations2 (flatten (map #(ratio-to-lilypond (:numerator %)
                                                  (:denominator %)) 
                              (rest combined-fraction-array)))
           _ (if debug (do (println "durations2") (pprint durations2)))
           duration (first durations-for-first-note) 
           chord (chord-snippet (get-chord pitch))
           ending (:source (get-attribute pitch :ending))
           ending-snippet (if ending
                            (render ending-template { :ending 
                                                     (:source (get-attribute pitch :ending))
                                                     }))
           pitch2 (if (and (= :dash (:my_type pitch)) 
                           (:dash_to_tie pitch))
                    (assoc pitch :normalized_pitch 
                           (get-in pitch [:pitch_to_use_for_tie :normalized_pitch] ) 
                           :octave (get-in pitch [:pitch_to_use_for_tie :octave] ))
                    ;; else
                    pitch)
           lilypond-octave  (octave-number->lilypond-octave (:octave pitch2))
           lilypond-pitch 
           (normalized-pitch->lilypond-pitch (:normalized_pitch pitch2))
           all-durations (concat (rest durations-for-first-note) durations2)   
           _ (if debug (println "all-durations"))
           _ (if debug (pprint all-durations))
           extra-tied-durations ;;; durations within current beat!
           (if (> (count all-durations) 0)
             (str lilypond-symbol-for-tie
                  (join lilypond-symbol-for-tie
                        (map (fn[duration] 
                               (render tied-pitch-template
                                       {
                                        ;; TODO: doesn't make sense!!!
                                        ;; should only apply to last!! ???
                                        :beam-start-or-end beam-start-or-end
                                        :duration duration
                                        :lilypond-pitch lilypond-pitch
                                        :lilypond-octave lilypond-octave
                                        }
                                       ))
                             all-durations
                             ))))
           ]
          (cond (:ignore pitch2)
                ""
                (:pointer pitch2)
                ""
                (and (= :dash (:my_type pitch2)) 
                     (:dash_to_tie pitch2))
                (render rest-template { :duration duration
                                       :chord chord
                                       :ending ending-snippet                
                                       })
                (and (= :dash (:my_type pitch2)) 
                     (not (:dash_to_tie pitch2)))
                (render rest-template { :duration duration
                                       :chord chord
                                       :ending ending-snippet                
                                       })
                (or (= :pitch (:my_type pitch2))
                    (= :dash (:my_type pitch2)))
                (render pitch-template 
                        {
                         :before-ornament-snippet 
                         (if has-before-ornament
                           (render before-ornament-template 
                                   {:grace-notes  
                                    (lilypond-grace-notes ornament) }))
                         :after-ornament-directive
                         (if has-after-ornament 
                           lilypond-after-ornament-directive) 
                         :lilypond-pitch lilypond-pitch
                         :lilypond-octave lilypond-octave
                         :duration duration
                         :beam-start-or-end beam-start-or-end
                         :lilypond-symbol-for-tie 
                         (if (and needs-tie 
                                  ;;and (:tied pitch)
                                  (not has-after-ornament)) 
                           lilypond-symbol-for-tie )
                         :mordent (if (get-attribute pitch2 :mordent) 
                                    mordent-snippet)
                         :begin-slur begin-slur
                         :extra-end-slur "" ;;; TODO 
                         :end-slur (if (get-attribute pitch2 :end_slur) ")" )
                         :ending ending-snippet                  
                         :chord chord
                         :after-ornament-contents 
                         (if has-after-ornament
                           (str " { " (lilypond-grace-notes ornament ) " }"))
                         :extra-tied-durations extra-tied-durations
                         }
                        )))))

(def lilypond-break  "\\break\n")

(defn beat-is-all-dashes?[beat] 
  { :pre [  (= (:my_type "beat"))  ]}
  (not-any? #(= :pitch (:my_type %)) (:items beat)))

(def beat-tuplet-template 
  (-> "lilypond/beat_with_tuplet.tpl" resource slurp trim))

(defn tuplet-numerator-for-odd-subdivisions[subdivisions-in-beat]
  ;; fills in numerator for times. For example
  ;; \times ???/5 {d'16 e'8 d'16 e'16 }
  ;; The ??? should be such that 5/16 *  ???/5 =  1/4
  ;; So ??? = 4
  ;; TODO: dry with duration code
  (cond (= 3 subdivisions-in-beat) 
        2 
        (<  subdivisions-in-beat 8)
        4 
        (< subdivisions-in-beat 16)
        8 
        (< subdivisions-in-beat 32)
        16 
        (< subdivisions-in-beat 64)
        32 
        true
        32 
        )
  )



(defn starts-with-rest[items]
  { :pre [(vector? items) ]
   :post [ (contains? #{true nil false} % )]
   }
  (:rest (some #(if (#{:pitch :dash} (:my_type %)) %) items))
  )
(defn draw-beat[beat]
  { :pre [(= :beat (:my_type beat)) ]
   :post [ (string? %)]
   } 
  (if true (do 
              (println "entering draw-beat, beat is") (pprint beat)))
  (if false (do
              (println "entering draw-beat, beat is:")
              (pprint beat)))
  ;; TODO: don't beam if starts with rest: ie  -S
  ;; Manually beam beat as follows: SR -> c'[ d']  
  ;; Only if more than one pitch in the beat of course
  ;; But don't beam if there is a quarter note which can be the
  ;; case with S-R
  (let [
        ;; Use pitch-ids to identify first and last pitches
        starts-with-rest (starts-with-rest (:items beat))
        pitch-ids (map :pitch-counter 
                       (filter 
                         #(and (#{ :dash :pitch } (:my_type %))
                               (:pitch-counter %))
                         (:items beat)))
        subdivisions (:subdivisions beat)
        first-pitch (some #(if (= :pitch (:my_type %)) %) (:items beat))
        ;; TODO: rewrite. Should deal with durations
        do-not-beam-case (and (#{3 5 7 9} subdivisions) 
                              (some 
                                (fn[pitch] 
                                  (and
                                    (#{:pitch :dash}  (:my_type pitch))
                                    (not (:ignore pitch))
                                    (> 
                                      (/ (:numerator pitch)
                                         (:denominator pitch))
                                      (/ 1 2))))
                                (:items beat))) 
        beamable? 
        (and (> (count pitch-ids) 1)
             (not starts-with-rest)
             (not do-not-beam-case))
        beat-ary 
        (map (fn draw-beat-item[ item]
               (let [
                     ;; If this is the first pitch or tied rest and there are
                     ;; more than one in the beat, add [ to end of note to
                     ;; indicate beam start.
                     beam-start-or-end
                     (cond (and beamable?
                                (= (first pitch-ids) (:pitch-counter item)))
                           lilypond-beam-start 
                           (and beamable?      
                                (= (last pitch-ids) (:pitch-counter item)))
                           lilypond-beam-end)
                     my-type (:my_type item)
                     _ (if true (println "my-type is" my-type))
                     ]
                 (cond (#{:pitch :dash} my-type)
                       (draw-pitch item (:subdivisions beat)
                                   beam-start-or-end)
                       )))
             (:items beat))
        beat-content (join " " beat-ary)
        ]
    (if (and (not (#{0 1 2 4 8 16 32 64 128} (:subdivisions beat)))
             (not (beat-is-all-dashes? beat)))
      (render beat-tuplet-template {:beat-content  beat-content
                                    :tuplet-numerator 
                                    (tuplet-numerator-for-odd-subdivisions (:subdivisions beat))
                                    :subdivisions (:subdivisions beat)
                                    })
      ;; else
      beat-content)     
    ))

(defn draw-barline[barline]
  (barline->lilypond-barline (:my_type barline)))

(defn draw-measure[measure]
  { :pre [(= :measure (:my_type measure))]} 
  (join " "
        (map 
          (fn draw-measure-item[item]
            (let [my-type (:my_type item)]
              (cond 
                (= :beat my-type)
                (draw-beat item)
                )))
          (:items measure)
          )))

(def draw-line-break
  ;; Lilypond text for line break.
  ;; Lilypond doesn't like  left-repeat break barline
  ;; That is why I insert an invisible grace note spacer after the
  ;; break. Otherwise lilypond will combine the left-repeat and barline
  ;; and you lose the left repeat.
  ;; Probably better to examine bars at end of line and beginning of next
  ;; line and combine them into one.
  (str " \\break        " lilypond-invisible-grace-note " \n"))

(defn draw-line[line]
  ;; line consists of items consisting of
  ;; optional :line_number followed by :barline :measure :measure etc "
  ;; We don't render line numbers in lilypond. (yet)"
  (let [
        first-item (first (:items line))
        my-items (if (= :line_number (:my_type first-item))
                   (rest (:items line))
                   (:items line))

        ] 
    (join " " 
          (map (fn draw-line-item[item]
                 (let [my-type (:my_type item)]
                   (cond (= :measure my-type)
                         (draw-measure item)
                         (:is_barline item)
                         (draw-barline item)
                         )))
               my-items))))


(defn is-abc-line[line]
  (if (nil? (:kind line))
    false
    ;; else
    (re-find #"abc" (:kind line))))

(defn notation-is-in-abc[composition-data]
  (some is-abc-line (:lines composition-data)))

(def transpose-template
  (-> "lilypond/transpose.tpl" resource slurp trim))

(def time-signature-template
  (-> "lilypond/time_signature.tpl" resource slurp trim))

(def omit-time-signature-snippet
  "Returns a lilypond snippet that prevents printing of the time signature"
  (-> "lilypond/omit_time_signature.txt" resource slurp trim))

(defn transpose-snippet[composition-data]
  "return transpose snippet for lilypond"
  "Don't transpose non-sargam."
  (let [my-key (:key composition-data)]
    (cond 
      (nil? my-key) 
      ""
      (= "c" (lower-case (:key composition-data)))
      ""
      (notation-is-in-abc composition-data)
      ""
      true
      (render transpose-template 
              {:key 
               (normalized-pitch->lilypond-pitch 
                 (upper-case (:key composition-data)))
               }
              ))))

(defn extract-lyrics[x]
  (map :syllable 
       (filter #(and (not (:pointer %)) (#{:pitch :dash} (:my_type %))
                     (:syllable %))
               (my-seq2 x))))

(def composition-template
  (-> "lilypond/composition.tpl" resource slurp trim))

(def key-template
  (-> "lilypond/key.tpl" resource slurp trim))

(defn to-lilypond[doremi-data]
  {:pre  [(map? doremi-data)
          (= :composition (:my_type doremi-data))
          ]
   }
  "Takes parsed doremi-script and returns lilypond text"
  (render composition-template 
          {:transpose-snip 
           (transpose-snippet doremi-data) 
           :extracted-lyrics
           (apply str (join " " (extract-lyrics doremi-data)))
           :beats-per-minute 
           200
           :title 
           (:title doremi-data)
           :author 
           (:author doremi-data)
           :src-snippet 
           (str  "%{\n " (lilypond-escape (:source doremi-data)) " \n %}\n")
           :time-signature-snippet 
           (if (:time_signature doremi-data)
             (render time-signature-template 
                     {:time-signature (:time_signature doremi-data)})
             ;; else
             omit-time-signature-snippet) 
           :key-snippet 
           (render key-template 
                   { :key "c"  
                    ;; Always set key to c !! 
                    ;; Transpose is used to move it to the right key
                    :mode (lower-case (:mode doremi-data "major"))
                    }) 
           :notes
           (join draw-line-break (map draw-line (:lines doremi-data))) 
           }))

(def runtest false)
;;;;;;;;;;;; For testing ;;;;;
(if runtest
  ;; (use 'clojure.stacktrace) 
  ;; (print-stack-trace *e)
  (println
    (to-lilypond 
      (doremi_script_clojure.core/doremi-script-text->parsed-doremi-script 
        ;;    "-P -- -- --"
    "-- -S"
;;        "S - - - | - - - - |"
 ;;       "-S -"
        ;; (-> "fixtures/yesterday.txt" resource slurp)
        ;;  (-> "fixtures/aeolian_mode_without_key_specified.txt" resource slurp)
        ;;   " RGm\nS\n\n R\nS"
        ))

    )
  )


