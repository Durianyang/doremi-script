(ns doremi-script.doremi-core
  (:require	
    [instaparse.core :as insta]
    [clojure.string :refer 
     [split replace-first upper-case lower-case join] :as string] 
    [clojure.zip :as zip]
    [clojure.java.io :as io :refer [input-stream resource]]
    [clojure.pprint :refer [pprint]] 
    [clojure.walk :refer [postwalk]]
    ;; TODO: shouldn't know about to-lilypond from here!
    [doremi-script.utils :refer [items map-even-items is? get-attribute]]
    ))


(comment
  ;; to use in repl:
  ;; cpr runs current file in vim
  ;; cp% runs current form. vim-fireplace
  (set! *warn-on-reflection* true)
  (use 'doremi-script.doremi-core :reload) (ns doremi-script.doremi-core) 
  (use 'clojure.stacktrace) 
  (print-stack-trace *e)
  (use 'doremi-script.test-helper :reload)  ;; to reload the grammar
  (print-stack-trace *e)
  (pst)
  )

(def is-kind?
  #{:sargam-composition :doremi-composition :number-composition :hindi-composition})

(defn attribute-section->map[x]
  {
   :pre [(is? :attribute-section x)]
   :post [ (map? %)]
   }
  (apply array-map 
         (map-even-items #(-> % lower-case keyword)
                         (rest x)))
  )
(defn get-attributes[collapsed-parse-tree]
  (->> collapsed-parse-tree (filter #(is? :attribute-section %)) 
                        first
                        attribute-section->map))

(defn parse-failed?[x]
  (or (insta/failure? x) (string? x)))

(defn format-instaparse-errors
  "Tightens up instaparse error format by deleting newlines after 'of' "
  [z]
  { :pre [ (parse-failed? z)] 
   :post [(string? %)]
   }
  (if (string? z)
    z
    (let [a (with-out-str (println z))
          ;;_ (println "a is" a)
          [left,right] (-> a (split #"of"))
          ]
      (str left "of\n" 
           (if right 
             (string/replace right #"\n" " "))))))

(def doremi-script-grammar 
  ;;;Optional keyword arguments to insta/parser:
  ;;;   :start :keyword  (where :keyword is name of starting production rule)
  ;;;   :partial true    (parses that don't consume the whole string are okay)
  ;;;   :total true      (if parse fails, embed failure node in tree)
  ;;;   :unhide <:tags or :content or :all> (for this parse, disable hiding)
  ;;;   :optimize :memory   (when possible, employ strategy to use less memory)
  ;;;
  (insta/parser
    (slurp (resource "doremiscript.ebnf")) :total true))


(defn doremi-script-parse
  ([x] (doremi-script-parse x :composition))
  ([x kind]
  (if kind
    (insta/parse doremi-script-grammar x :start kind)
    (insta/parse doremi-script-grammar x)
    )))


(defn is-notation-system-name?
  [x]
  { :post [(instance? Boolean %)] }
  (contains? #{"sargam" "number" "abc" "hindi" "doremi" :doremi :sargam :number :abc :hindi} x))



(defn unique-for-assigned
  "Make a unique key using meta-data"
  [x]
  { :pre [(vector? x)]
   :post [(vector? %)]
   }
  [ (meta x) (first x)]) 

(defn in-assigned?
  "Tests whether x is in set my-set. Uses metadata to distinguish " 
  [my-set x]
  { :pre [(set? my-set)
          (vector? x)]
   :post [(instance? Boolean %)]
   }
  (contains? my-set (unique-for-assigned x)))


(defn sargam-pitch->normalized-pitch
  "Map sargam pitch to pitch in the key of 'C'.  M => F# "
  [x]
  (get {"S" "C"
        "r" "Db"
        "R" "D"
        "g" "Eb"
        "G" "E"
        "m" "F"
        "M" "F#"
        "P" "G"
        "d" "Ab"
        "D" "A"
        "n" "Bb" 
        "N" "B"
        "Sb" "Cb"
        "S#" "C#"
        "R#" "D#"
        "G#" "E#"
        "mb" "Fb"
        "Pb" "Gb"
        "P#" "G#"
        "D#" "A#"
        "N#" "B#"   
        } x "ERROR"))

(defn number-pitch->normalized-pitch[x]
  "Map from number pitch to pitch in the key of 'C'.  4# => F# "
  (get {"1" "C"
        "2b" "Db"
        "2" "D"
        "3b" "Eb"
        "3" "E"
        "4" "F"
        "4#" "F#"
        "5" "G"
        "6b" "Ab"
        "6" "A"
        "7b" "Bb"
        "7" "B"
        "1#" "C#"
        "2#" "D#"
        "3#" "E#"
        "4b" "Fb"
        "5b" "Gb"
        "5#" "G#"
        "6#" "A#"
        "7#" "B#"   
        } x "ERROR"))

(defn doremi-pitch->normalized-pitch[x]
  "Map from solfege pitch to pitch in the key of 'C'.  4# => F# "
  (get {"d" "C"
        "rb" "Db"
        "r" "D"
        "mb" "Eb"
        "m" "E"
        "f" "F"
        "f#" "F#"
        "s" "G"
        "lb" "Ab"
        "l" "A"
        "tb" "Bb"
        "t" "B"
        "d#" "C#"
        "r#" "D#"
        "m#" "E#"
        "fb" "Fb"
        "sb" "Gb"
        "s#" "G#"
        "l#" "A#"
        "t#" "B#"   
        } (lower-case x) "ERROR"))



(defn hindi-pitch->normalized-pitch[x]
  "Map from Hindi pitch to pitch in the key of 'C'."
  (get
    {
     "\u0938" "C"
     "\u0930" "D"
     "\u095A" "E"
     "\u092E" "F"
     "\u092a" "G"
     "\u0927" "A"
     "\u0929" "B"
     "\u0938#" "C#"
     "\u0930#" "D#"
     "\u095A#" "E#"
     "\u092E#" "F#"
     "\u092a#" "G#"
     "\u0927#" "A#"
     "\u0929#" "B#"
     "\u092E'" "F#"  ;; note the tick
     }
    x "ERROR"))


(defn remove-notation-system-prefix
  "Change keyword to remove notation prefixes. :sargam-pitch -> :pitch " 
  [k]
  { :pre [(keyword? k)]
   :post [(keyword? %)]
   }
  (let [my-name (name k)
        prefix (re-find  #"[^-]*(?-)" my-name)
        ]
    (if (and prefix (is-notation-system-name? prefix))
      (keyword (replace-first my-name #"^[^-]*-" ""))
      ;; else 
      k)
    ))

(defn make-it-kommal[pitch]
  ;; Only flatten D E A and B !!!!! and should only be
  ;; done for hindi-composition (I think)
  ;; hackish
{ :pre [(is? :pitch pitch)]
;; :post [(is? :pitch %)]
 }
  (when false (do
  (println "make-it-kommal")
  (pprint pitch)))
  (let [without-kommal (into [] (remove #(is? :kommal-indicator %) pitch))]
  ;;    [:pitch "D" [:kommal-indicator "_"] [:octave 0]]]]
 ;;   (pprint without-kommal)
    (if (#{"D" "E" "A" "B"} (second pitch))
      (into [] (update-in without-kommal [1] str "b"))
       pitch)
))
(comment
(when false
        (-> (str "सर" "|\n" " _") (doremi-text->collapsed-parse-tree nil) pprint)
)
)


(defn apply-kommal-to-pitches
  [original-tree] ;; assigned]
  (when false
  (pprint "apply-kommal-to-pitches, tree is")
 (pprint original-tree))
  (loop [loc (zip/vector-zip original-tree)
         id 0 ]
    (if (zip/end? loc)
      (zip/root loc)
      ;; else
      (let [current (zip/node loc)
            ]
        (cond 
          (and (is? :pitch current)
               (get-attribute current :kommal-indicator)
               )
          (recur 
            (zip/next 
              (zip/edit loc make-it-kommal)
              )
            id)
          :else 
          (recur (zip/next loc) id))))))

(defn match-slurs
  "add id to begin and end slurs" 
  [original-tree]
  {;; :pre [(map? original-tree)]
   ;;   :post [(map? %)]
   }
  ;;(pprint "matchslurs") (pprint original-tree)
  ;(assoc original-tree :parsed
  (loop [loc (zip/vector-zip original-tree)
         id 0 ]
    (if (zip/end? loc)
      (zip/root loc)
      ;; else
      (let [current (zip/node loc)
            ]
        (cond 
          (and (is? :pitch current)
               (get-attribute current :begin-slur)
               )
          (recur 
            (zip/next 
              (zip/edit loc conj [:begin-slur-id id])
              )
            id)
          (and (is? :pitch current)
               (get-attribute current :end-slur)
               )
          (recur (zip/next 
                   (zip/edit loc conj [:end-slur-id id])) (inc id))
          :else 
          (recur (zip/next loc) id))))))

;; (pprint (-> "(SS) (RR)\n\n(GG) (mm)"  doremi-text->collapsed-parse-tree))


(defn remove-notation-system-prefixes
  "Removes notation system prefixes from the tree" 
  [original-tree]
  { :pre [(vector? original-tree)]
   :post [(vector? %)]
   }
  (loop [loc (zip/vector-zip original-tree) ]
    (if (zip/end? loc)
      (zip/root loc)
      (recur (zip/next
               (cond  (and (vector? (zip/node loc)) (keyword? (first (zip/node loc))))
                     (zip/edit loc (fn[y] (assoc y 0 (remove-notation-system-prefix (first y))))) 
                     :else loc))))))

(defn normalize-pitches
  "Replace pitch names to CDEFGAB style from the style found in
  the parse tree (number,sargam,hindi)"
  [original-tree]
  { :pre [(vector? original-tree)]
   :post [(vector? %)]
   }
  (loop [loc (zip/vector-zip original-tree) ]
    (if (zip/end? loc)
      (zip/root loc)
      (recur (zip/next
               (cond 
                 (and (vector? (zip/node loc))
                      (#{:sargam-pitch :sargam-ornament-pitch } (first (zip/node loc))))
                 (zip/edit loc  (fn[x] (assoc x 1 (sargam-pitch->normalized-pitch (second x)))))
                 (and (vector? (zip/node loc))
                      (#{:doremi-pitch :doremi-ornament-pitch } (first (zip/node loc))))
                 (zip/edit loc  (fn[x] (assoc x 1 (doremi-pitch->normalized-pitch (second x)))))
                 (and (vector? (zip/node loc))
                      (#{:hindi-pitch :hindi-ornament-pitch } (first (zip/node loc))))
                 (zip/edit loc  (fn[x] (assoc x 1 (hindi-pitch->normalized-pitch (second x)))))
                 (and (vector? (zip/node loc))
                      (#{:number-pitch :number-ornament-pitch } (first (zip/node loc))))
                 (zip/edit loc  (fn[x] (assoc x 1 (number-pitch->normalized-pitch (second x)))))
                 :else loc))))))
;; (-> "drm" (doremi-text->parse-tree :sargam-composition))

(defn add-kind[x kind]
  ;; Parsed data come in like this:
  ;;
  ;;[:composition [:sargam-composition [:sargam-stave [:sargam-notes-line [:sargam-measure
  ;;[:sargam-beat [:sargam-pitch S] [:sargam-pitch S] [:sargam-pitch S]]]]]]]
  ;;  OR
  ;;
  ;;[:composition [:abc-composition [:attribute-section Title me] [:abc-stave [:abc-notes-line [:abc-measure [:abc-beat [:abc-pitch C]]] [:barline [:rig
  ;;ht-repeat]]]] [:abc-stave [:abc-notes-line [:abc-measure [:abc-beat [:abc-pitch D]] [:abc-beat [:abc-pitch E]] [:abc-beat [:abc-pitch F]]]]]]]
  ;;nil
  ;; or
  ;;  [:composition [:stave [:notes-line [:measure [:beat [:pitch "Ab"] [:pitch "Db"]
  ;;  [:pitch "F"]]]]]]
  ;;
  ;; Grab :sargam-composition and put it in :attributes-section as "kind".
  ;; Then return the rest... Basically remove the first keyword.
  ;; attribute section may be absent...
  (cond
    kind 
    (let [ has-attributes (= :attribute-section (first (second x)))
          ]
      (if has-attributes
        (update-in x [1] conj "kind" kind)
        (into [] (concat [ (first x)]
        [ [:attribute-section "kind" kind]]
         (subvec x 1)
         ))))


    (= :attribute-section (first (second (second x))))
    (let [z (second x)
          attributes (first (second x))]
      (update-in z [1] conj "kind" (first z)) 
      )
    true
    (into [] (concat [:composition [:attribute-section "kind" (first (second x))]] (rest (second x))))

    ))
;; (-> "\nS|\n" (doremi-text->collapsed-parse-tree :sargam-composition)) to-lilypond )
(defn doremi-text->parse-tree
  "Parse doremi text into parse tree or failure." 
  ([txt] (doremi-text->parse-tree txt :sargam-composition))
  ([^java.lang.String txt kind]
  { :pre [(string? txt)]
   :post [
          ;;;   (do (pprint %) true)

          (or (vector? %)
              (insta/failure?  %) true)] }

  (cond (= "" txt)
        "Nothing entered"
        (not= -1 (.indexOf txt "\t"))
        "Tabs are not allowed"
        true
        (let [ parsed (doremi-script-parse txt kind)
              ]
          (if (insta/failure? parsed)
            parsed
            ;; else
            (-> (add-kind parsed kind)  normalize-pitches remove-notation-system-prefixes) 
            )
          ))))

;; (test-add-kind)
(comment
(defn test-add-kind[]
  (do
    (pprint (-> "Title:hi\n\ndrm" doremi-text->parsed )))
    (pprint (-> "drm" (doremi-text->parse-tree :sargam-composition)))
    (pprint (-> "drm" (doremi-text->parse-tree :composition)))
    (pprint (-> "drm" (doremi-text->parse-tree :sargam-composition)))
    (pprint (-> "drm\n___" (doremi-text->parse-tree :number-composition)))
    ))









(defn start-index[x]
  (let [x (insta/span x)]
    (when x
      (first x))))


(defn line-column-map[my-map my-line]
  (when false (println "entering line-column-map, my-map=" my-map))
  (let [line-start (start-index my-line) 
        ]
    (reduce (fn[accum obj]
              (when nil (println "line-column-map:, obj =" obj)
                (println "start-index obj=" (start-index obj)) 
                )
              (let [start-index (start-index obj)
                    column (if start-index 
                             (- start-index line-start))
                    _ (when nil (println "obj" obj))
                    ]
                (cond (not start-index)
                      accum
                      (is? :ornament obj) 
                      ;; Ornaments are not directly over notes. They are before or after
                      ;; Add the ornament twice in the column map.
                      ;; ;;  [:ornament [:G] [:m] [:P] [:D]]
                      (let [
                            span (insta/span obj) 
                            ornament-string-length (apply - (reverse span))
                            column-for-after-ornament (dec column)
                            column-for-before-ornament (+ column  ornament-string-length)
                            ]
                        (assoc accum
                               column-for-after-ornament
                               (conj (get accum column-for-after-ornament [])
                                     (conj obj :after))
                               column-for-before-ornament
                               (conj (get accum column-for-before-ornament [])
                                     (conj obj :before))
                               )
                        )
                      true
                      (let [ column (- start-index line-start)
                            _ (when false ( println "true case, column is" column " obj is" obj)) ]
                        (assoc accum 
                               column 
                               (conj (get accum column [])
                                     obj))
                        ))))
            my-map
            (tree-seq vector? identity my-line)
            )))



(defn takes-values-from-column?[x]
  (contains? #{:pitch :dash :barline  } 
             x))
(comment
  [:composition
   [:sargam-composition
    [:sargam-stave
     [:sargam-upper-line [:upper-line-dot]]
     [:sargam-upper-line [:upper-line-two-dots]]
     [:sargam-notes-line
      [:sargam-measure [:sargam-beat [:sargam-pitch "S"]]]]]]]
  )

(defn is-upper-dot?[x]
  (and (vector? x) (contains? #{:upper-line-dot :upper-line-two-dots } 
                              (first x))))

(defn is-dot?[x]
  (contains? #{:upper-line-dot :upper-line-two-dots 
               :lower-line-dot :lower-line-two-dots}
             (first x)))


(defn is-lower-line?[x]
  (and (vector? x)
       (contains? #{:lower-octave-line :lyrics-line} (first x))))

(defn lines->column-map[lines]
  (reduce (fn[accum item] 
            (line-column-map accum item)) {}
          (remove keyword? (remove #(or (is? :notes-line %) (is? :lyrics-line %)) lines))))

;;(println (-> ".\nS" doremi-text->parsed ))


(defn pitch->octave[pitch]
  {
   :pre [ (or (= :ornament-pitch (first pitch)) (is? :pitch pitch))] 
   :post[ (integer? %)]
   }
  (->> pitch (filter vector?) 
       (map first) 
       (map {:upper-line-dot 1
             :upper-line-two-dots 2
             :lower-line-dot -1
             :lower-line-two-dots -2 }
            )
       (remove nil?)
       (apply +))
  )


(defn calculate-octave[x]
  (if (not (or (is? :pitch x)
               (is? :ornament-pitch x) 
               ))
    x
    (let [without-dots (into [] (remove #(and (vector? %) (is-dot? %)) x))
          octave (pitch->octave x)
          ]
      (into [] (conj without-dots [:octave octave]))
      )))



(defn assign-ornament-octaves[assigned my-stave]
  {;; :pre [(is-stave? my-stave)] 
   :post [(is? :stave %)] }
  (when false
    (pprint @assigned)
    (pprint my-stave)
    )
  (let [column-map (lines->column-map 
                     (filter #(is? :upper-line %) (items my-stave)))
        ]
    (into [] 
          (map 
            (fn map-fn[line] 
              (cond (is? :upper-line line)
                    (postwalk 
                      (fn assign-dots-postwalk-fn[item] 
                        (cond 
                          (is? :ornament-pitch item)
                          ;; Look for dot in this column from lines above and below this one. But not in the lower lines
                          (let [column (- (start-index item) (start-index line))
                                dots-from-upper-lines (remove (partial in-assigned? @assigned)
                                                              (filter is-upper-dot?
                                                                      (column-map column [])))
                                ]
                            (if (empty? dots-from-upper-lines)
                              item
                              (let [
                                    fixed-dots (map (fn[x] 
                                                      {:pre [(is-upper-dot? x)]
                                                       :post [(is-dot? x)] }
                                                      (if (> (start-index x) (start-index item))
                                                        ({[:upper-line-dot] [:lower-line-dot]
                                                          [:upper-line-two-dots] [:lower-line-two-dots]}
                                                         x "wtf")
                                                        x))  dots-from-upper-lines)
                                    ] 
                                (reset! assigned (apply conj @assigned
                                                        (map unique-for-assigned dots-from-upper-lines)))
                                (calculate-octave (apply conj item fixed-dots)))
                              ;;(calculate-octave (if (not-empty nodes-in-this-column)
                              )
                            )
                          true
                          item)) line)
                    true
                    line 
                    )) my-stave)))) 


(defn assign-syllables[assigned stave]
  (let [ syls-to-apply (atom (mapcat items (filter #(is? :lyrics-line %) stave)))
        in-slur (atom false)
        ]
    (map (fn[line] (if-not (is? :notes-line line) line
                     ;; else
                     (postwalk (fn walk-fn[item]
                                 (cond  (is? :pitch item)
                                       (let [syl (if (not @in-slur) (first @syls-to-apply))

                                             blank-syl-for-lilypond "\" \""
                                             ret-val 
                                           ;; original  (if syl (conj item [:syl syl]) item)
                                             ;; new
                                             (if (not @in-slur)
                                               (conj item [:syl
                                                        (or syl blank-syl-for-lilypond)
                                                           ])
                                               item)
                                             has-begin-slur (some #(is? :begin-slur %) item)
                                             has-end-slur (some #(is? :end-slur %)  item)
                                             ]
                                         (if syl (swap! syls-to-apply rest))
                                         (cond (and has-begin-slur has-end-slur)
                                               nil
                                               has-begin-slur
                                               (reset! in-slur true)
                                               has-end-slur
                                               (reset! in-slur false))
                                         ret-val)
                                       true
                                       item
                                       ))     line)
                     )) stave)
    ))


(defn handle-slurs[assigned stave ]
  (map (fn[line]
         (if-not (is? :notes-line line) 
           line
           (let [
                 pitch-positions 
                 (map start-index (filter #(is? :pitch %) (tree-seq vector? identity line)))
                 end-slur-positions (map start-index (filter #(is? :end-slur %)  (tree-seq vector? identity line)))
                 begin-slur-positions (map start-index (filter #(is? :begin-slur %) (tree-seq vector? identity line)))

                 pitches-needing-begin-slurs 
                 (into #{}  (map (fn[slur-position]
                                   (first (filter 
                                            (partial < slur-position) pitch-positions)))
                                 begin-slur-positions))
                 pitches-needing-end-slurs 
                 (into #{}  (map (fn[slur-position]
                                   (last (filter 
                                           (partial > slur-position) pitch-positions)))
                                 end-slur-positions))
                 ]
             (postwalk (fn walk-line[item] 
                         (cond (is? :pitch item)
                               (let [ items-to-conj  
                                     (remove nil? 
                                             [
                                              (if (contains? pitches-needing-end-slurs (start-index item)) [:end-slur])
                                              (if (contains? pitches-needing-begin-slurs (start-index item)) [:begin-slur])
                                              ])]
                                 (if (not-empty items-to-conj)
                                   (apply conj item items-to-conj)
                                   item))
                               (is? :begin-slur item)
                               nil
                               (is? :end-slur item)
                               nil
                               (is? :beat item)
                               (into [] (remove nil? item))
                               (is? :measure item)
                               (into [] (remove nil? item))
                               true
                               item))
                       line 
                       ))))
       stave)
  )
(defn assign-to-notes-line[assigned stave ]
  {
   :pre [(is? :stave stave)]
   :post [(is? :stave %)
          ]
   }
  (let [ column-map (lines->column-map (items stave))
        notes-line (first (filter #(is? :notes-line %) (items stave)))     
        notes-line-start-index (start-index notes-line)
        line-starts (map start-index (items stave))
        line-start-for-position  (fn line-start-for-position-fn[position] 
                                   (last (filter (fn[x] (>= position x)) line-starts)))
        line-start-for-node (fn line-start-for-node[node]
                              (line-start-for-position (start-index node)))
        column-for-node (fn[node] (let [my-start-index (start-index node)]
                                    (- my-start-index (line-start-for-position my-start-index))))
        ]
    (into [] (map (fn[line] 
                    (if-not (is? :notes-line line)
                      line
                      (postwalk (fn[item] 
                                  (when false (do
                                        (println "postwalk in collapse item is" item "\n\n")))
                                  (cond 
                                    (and (vector? item) (is? :pitch item) (< (start-index item) notes-line-start-index))
                                    item  ;; skips ornaments
                                    (and (vector? item) 
                                         (takes-values-from-column? (first item)))
                                    (let [column (column-for-node item)
                                          start-index (start-index item)
                                          nodes-in-this-column1 
                                          (filter (fn[x] (#{:upper-line-dot :upper-line-two-dots
                                                            :lower-line-dot 
                                                            :lower-line-two-dots :ornament 
                                                            :chord
                                                            :kommal-indicator 
                                                            :tala
                                                            :ending 
                                                            :mordent} (first x))) 

                                                  (remove (partial in-assigned? @assigned) (column-map column [])))
                                          ;; remove ornaments from nodes-in-this-column when item is
                                          ;; not pitch
                                          nodes-in-this-column (if-not (is? :pitch item) 
                                                                 (remove #(is? :ornament %)  nodes-in-this-column1)
                                                                 nodes-in-this-column1)
                                          ]

                                      (calculate-octave (if (not-empty nodes-in-this-column)
                                                          (do
                                                            (reset! assigned (apply conj @assigned (map unique-for-assigned nodes-in-this-column)))
                                                            (apply conj item nodes-in-this-column) 
                                                            )
                                                          item)))
                                    true
                                    item
                                    )) line)))
                  stave 
                  ))))

(defn collapse-stave
  "Assigns items based on indentation" 
  [stave]
  { :pre [(vector? stave)
          (is? :stave stave)]
   :post [(is? :stave %)]
   }
  (let [my-assigned (atom (hash-set))]
    (into [] (->> stave 
                  (handle-slurs my-assigned)
                  (assign-ornament-octaves my-assigned)
                  (assign-to-notes-line my-assigned)
                  (remove (fn[x] (and (vector? x) (#{:upper-line :lower-octave-line} (first x)))))
                  (into [])
                  (assign-syllables my-assigned)
                  (into [])
                  apply-kommal-to-pitches
                  ))))





;;(pprint (-> "S- |\n.\nHi" doremi-text->collapsed-parse-tree))
;;(pprint (-> "S- |\nHi" doremi-text->collapsed-parse-tree))



(comment
 (def sargam-str
   "[a dogG]\nS-R |\nhe-llo"
   )
  (println (-> 
   "[a 9dogG]\nS-R |\nhe-llo"
               (doremi-text->parse-tree nil)))
      (spit "/home/john/doremi-script/out.ly"
        (-> sargam-str  (doremi-text->lilypond nil)))
  )



(defn doremi-text->collapsed-parse-tree
  ([txt ] (doremi-text->collapsed-parse-tree txt :sargam-composition))
  ([txt kind] 
  {
   :pre [(string? txt)
         (keyword? kind)
         (is-kind? kind) 
         ]
   :post [ ;;(do (pprint %) true)
          (map? %)
          (:src %)
          (or (:error %)
              (and (vector? (:parsed %))
                   (is? :composition (:parsed %))
                   (:parsed %)))
          ]
   }
  (let [ parsed  (doremi-text->parse-tree txt kind) ]
    (if (parse-failed? parsed)  ;; error
      {:src txt
       :parsed nil
       :lilypond nil
       :error (-> parsed format-instaparse-errors)
       }
      (let [
            collapsed-parse-tree
            (into [] (map (fn[z] (if (is? :stave z)
                                   (collapse-stave z)
                                   z))
                          parsed))
            my-map (->> collapsed-parse-tree (filter #(is? :attribute-section %)) 
                        first
                        attribute-section->map)
            _ (when false (pprint my-map))
            _ (when false (println "**") (pprint collapsed-parse-tree))
            ]
        {:src txt
         :parsed (match-slurs collapsed-parse-tree)
         :attributes my-map  ;; TODO
         :error nil}
        ))))) 

;; (pprint (-> "4|123"  doremi-text->collapsed-parse-tree))
;; (pprint (-> "4|123"  doremi-text->parse-tree))
;; (pprint (-> "4\n|123"  doremi-script-parse))
;; (pprint (-> "Title: hi\n\n|SSS\nHi"  doremi-text->parsed))
;; (pprint (-> "Title: hi\n\n|123"  doremi-text->parsed))
;; (pprint (-> "123|" (doremi-text->parsed :number-composition)))
;; (pprint (-> "SSS" doremi-script-parse))
;; (pprint (-> "SSS" doremi-script-parse))
(defn doremi-text->parsed
  ([txt] (doremi-text->parsed txt :composition))
  ([txt kind] 
  {
   :pre [(string? txt)]
;;;;    ;;;       :post [ ;;(do (pprint %) true)
;;;;              (map? %)
;;;;              (:src %)
;;;;              (or (:error %)
;;;;                  (and (vector? (:parsed %))
;;;;                      ;; (is? :composition (:parsed %))
;;;;                       (:lilypond %)
;;;;                       (:parsed %)))
     ;;     ]
   }
   (println "entering doremi-text->parsed, txt is " txt "kind is " kind)
  (let [ parsed  (doremi-text->parse-tree txt kind) ]
    (if (parse-failed? parsed)  ;; error
      {:src txt
       :parsed nil
       :lilypond nil
       :error (-> parsed format-instaparse-errors)
       }
      (let [
            collapsed-parse-tree
            (into [] (map (fn[z] (if (is? :stave z)
                                   (collapse-stave z)
                                   z))
                          parsed))
            _ (when false (println "**") (pprint collapsed-parse-tree))
            attributes (get-attributes collapsed-parse-tree)
;;;;            lilypond (doremi-script.to_lilypond/to-lilypond 
;;;;                      {:parsed collapsed-parse-tree
;;;;                      :src txt
;;;;                       :attributes attributes
;;;;                       }
;;;;                      ) 
            ]
        {:src txt
         :parsed collapsed-parse-tree 
         :attributes attributes
         :error nil}
        ))))) 



(comment defn test-dialect-normalization[]
         (def sargam-str (str "R.\n"" |SRGM PP#|"))
  (let [abc-str (str "D\n" "|CDEF# GG#|")
        sargam-str (str "R.\n"" |SRGM PP#|")
        hindi-str (str "सर" "|\n" " _")
        doremi-str "drmf sltd"
        ]
    (println "hindi raw parse results")
    (-> hindi-str  (doremi-script-parse nil) pprint)
    (println "hindi normalized")
    (-> hindi-str  (doremi-text->parse-tree nil) pprint)
    (println "hindi to lilypond")
    (-> hindi-str  (doremi-text->lilypond nil) println)
    (println "hindi to collapsed")
    (when false
      (println abc-str)
      (println "abc raw parse results")
      (-> abc-str  (doremi-script-parse nil) pprint)
      (println "abc normalized")
      (-> abc-str  (doremi-text->parse-tree nil) pprint)
      (println "abc to-lilypond")
      (-> abc-str  (doremi-text->lilypond nil) println)
      (println "sargam raw parse results")
      (-> sargam-str  (doremi-script-parse nil) pprint)
      (println "sargam normalized")
      (-> sargam-str  doremi-text->collapsed-parse-tree  pprint)
      (println "sargam to-lilypond")
      (-> sargam-str  (doremi-text->lilypond nil) println)
      (println "doremi to-lilypond")
      (-> doremi-str  (doremi-text->lilypond nil) println)
      )
    ))
;; (test-dialect-normalization)
;;  (-> "123"  (doremi-text->parse-tree nil) pprint)

(when false
        (-> "+\n| S - - -" (doremi-text->collapsed-parse-tree nil) pprint)
        (-> (str "सर" "|\n" " _") (doremi-text->collapsed-parse-tree nil) pprint)
)



;;(print-stack-trace *e)
;; (println (time (test-all)))
(comment defn test-all
  "Note 2 different bodies with different parameters"
  ([dir-str match-str]
   { :pre [(string? dir-str)
           (string? match-str)]
    }
   (let [my-dir (-> dir-str io/resource io/file)]
     (time (str "Processed "
                (->> my-dir 
                     file-seq 
                     (filter (fn[^java.io.File x] (.matches (.getName x) match-str))) 
                     (map test-all-process-file) 
                     count)
                " files"))
     ))
  ([]
   (->> "fixtures" 
        io/resource
        io/file
        file-seq 
        (filter (fn[^java.io.File x] (.endsWith (.getName x) ".txt")))
        (sort-by (fn[^java.io.File x] (.getName x)))
        (pmap test-all-process-file) count))
  ) 

(def x 
  "C | A 

  | CDbDEb EFF#G AbABbB C#D#E#F#F |

  | C#D#E#F# F :|

  F#")
(def y "Key: B\nMode:Lydian\n\nC :|\n\nD E F    ")
(def z "Title:me\n\nC :|\n\nD E F    ")
(def x "oh say can you see\n\nC :|\n\nD E F    ")
(def s "SSS")
(def j "Key:G\n\n123")

(comment defn testn[x]
  (let [s (apply str (repeat x "SRG")) ]
    (println (time (-> s doremi-text->collapsed-parse-tree nil)))))

(comment
  (testn 10000))

