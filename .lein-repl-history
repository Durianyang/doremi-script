 (sorted-map-by > 1 "a", 2 "b", 3 "c")
 (sorted-map-by > "aa" "a", "bbbb" "b", "cccc" "c")
(compare "108" "23")
(compare "23" "108")
(compate :a :b)
(compare :a :b)
(compare :b :a)
(keys {1 2 3 4})
(into (set) [1 2 3])
(set 1 2)
(into (hash-set) [1 2 3])
(concat [1 2] nil)
(into {} [1 2])
(apply (hash-map) [1 2])
(apply hash-map [1 2])
{:items nil}
(:items {:items nil})
(def x {:items nil})
x
(def z [[{:_my_type :sargam_pitch,
   :_source "S",
   :_start_index 0,
   :denominator 1,
   :normalized_pitch "C",
   :numerator 3,
   :pitch_source "S"}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 1}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 2}]
 [{:_my_type :sargam_pitch,
   :_source "R",
   :_start_index 3,
   :denominator 1,
   :normalized_pitch "D",
   :numerator 2,
   :pitch_source "R"}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 4}]]
)
(count z)
(apply concat z)
(count (apply concat z))
(def i [[1 2 3]])
(apply concat i)
(into [] (apply concat i))
(def i [[1 2 3] 4])
(into [] (apply concat i))
(flatten '(({:_my_type :sargam_pitch,
   :_source "S",
   :_start_index 0,
   :denominator 1,
   :normalized_pitch "C",
   :numerator 3,
   :pitch_source "S"}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 1}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 2}
  {:_my_type :sargam_pitch,
   :_source "R",
   :_start_index 3,
   :denominator 1,
   :normalized_pitch "D",
   :numerator 2,
   :pitch_source "R"}
  {:numerator 1, :_my_type :dash, :_source "-", :_start_index 4}))
)
(into [] '(1 2 3))
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (print-stack-trace *e)
 (use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (print-stack-trace *e)
(quit)
 (use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (print-stack-trace *e)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (print-stack-trace *e)
(pos? 2)
(map pos? [1 2 -1])
(first pos? [1 2 3])
(some pos? [1 2 3])
(some #(pos? %)  [1 2 3])
(some (fn [x] (= (:_my_type %) :sargam_line  [1 2 3])))
(some (fn [x] (= (:_my_type x) :sargam_line  [1 2 3])))
(some (fn [x] (= (:_my_type x) :sargam_line))   [1 2 3])
(flatten [{:_my_type :sargam_pitch,
   :_source "r",
   :_start_index 0,
   :denominator 1,
   :normalized_pitch "Db",
   :numerator 1,
   :pitch_source "r"}
  {:_my_type :sargam_pitch,
   :_source "r",
   :_start_index 1,
   :denominator 1,
   :normalized_pitch "Db",
   :numerator 1,
   :pitch_source "r"}])
(def z [[1 2 3] 4 5])
(map (fn[x] (if (vector? x) (first x) [x] z)
(map (fn[x] (if (vector? x) (first x) [x])) z)
)
(map (fn[x] (if (vector? x) (first x) x)) z)
z
(map (fn[x] (if (vector? x) x (vector x))) z)
(map concat (map (fn[x] (if (vector? x) x (vector x))) z))
(map concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z)))
(class (map concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z))))
(doall (map concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z))))
(doall (into [] (map concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z)))))
(into [] (map (fn[x] (if (vector? x) x (vector x))) z))
(concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z)))
(into [] (concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z))))
(apply concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z))))
(apply concat (into [] (map (fn[x] (if (vector? x) x (vector x))) z)))
(reslove list)
(resolve list)
(resolve 'list)
(def y 1)
(resolve y)
(resolve 'y)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(first nil)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(count ())
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
quit
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(run-through-parser "S")
yesterday
(def yesterday (get-parser2 (slurp-fixture "yesterday.txt")))
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
yesterday
(run-through-parser yesterday)
quit
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
quit
(def z {:_subdivisions 0, :_start_index 1307, :_source (S, :_my_type :beat, :items [{:items [{:_my_type :begin_slur, :_source (, :_start_index 1307} {:pitch_source S, :numerator 1, :normalized_pitch C, :denominator 1, :_my_type :pitch, :_source S, :_start_index 1308}], :_my_type :begin_slur_sargam_pitch, :_source (S, :_start_index 1307}]})
{:_subdivisions 0, :_start_index 1307, :_source (S, :_my_type :beat, :items [{:items [{:_my_type :begin_slur, :_source (, :_start_index 1307} {:pitch_source S, :numerator 1, :normalized_pitch C, :denominator 1, :_my_type :pitch, :_source S, :_start_index 1308}], :_my_type :begin_slur_sargam_pitch, :_source (S, :_start_index 1307}]}
{:_subdivisions 0, :_start_index 1307, :_source (S, :_my_type :beat, :items [{:items [{:_my_type :begin_slur, :_source (, :_start_index 1307} {:pitch_source S, :numerator 1, :normalized_pitch C, :denominator 1, :_my_type :pitch, :_source S, :_start_index 1308}], :_my_type :begin_slur_sargam_pitch, :_source (S, :_start_index 1307}
{:_subdivisions 0, :_start_index 1307, :_source (S, :_my_type :beat, :items [{:items [{:_my_type :begin_slur, :_source (, :_start_index 1307} {:pitch_source S, :numerator 1, :normalized_pitch C, :denominator 1, :_my_type :pitch, :_source S, :_start_index 1308}], :_my_type :begin_slur_sargam_pitch, :_source (S, :_start_index 1307}]}
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
{:_subdivisions 0,
 :_start_index 1307,
 :_source "(S",
 :_my_type :beat,
 :items
 [{:items
   [{:_my_type :begin_slur, :_source "(", :_start_index 1307}
    {:pitch_source "S",
     :numerator 1,
     :normalized_pitch "C",
     :denominator 1,
     :_my_type :pitch,
     :_source "S",
     :_start_index 1308}],
   :_my_type :begin_slur_sargam_pitch,
   :_source "(S",
   :_start_index 1307}]}
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
bad-beat
(pprint bad-beat)
(run-through-parser "(S")
(nth 2 [1 2 3])
(nth  [1 2 3] 2)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(doremi-script-parse yesterday)
(first [1 2])
(update-in [1 2] [1] inc)
(append [1 2 ] 3)
(conj [1 2 ] 3)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (use 'clojure.stacktrace)
(print-stack-trace *e)
 (concat nil [1 2])
(into [] [1 2 3]_
(into [] [1 2 3])
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(third [1 2 3])
(quit)
(def ctr (atom -1))
(swap! ctr inc)
ctr
@ctr
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
z1
(pprint (my-seq z1))
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(pprint (my-seq z1))
(count (my-seq z1))
(def z2 (my-seq z1))
(nth z2 0)
(nth z2 1)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
z1
(my-seq z1)
(count (my-seq z1))
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(count (my-seq z1))
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(count (my-seq z1))
(concat [1] [2 3 4])
(into [] (concat [1] [2 3 4]))
(map inc [1 2 3])
(subvec [1 2] 2)
(subvec [1 2] 5)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(use 'clojure.stacktrace) 
(print-stack-trace *e)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
quit
(quit)
(defn[ [first-item & rest]] (pprint first-item) (pprint rest))
(defn yy[ [first-item & rest]] (pprint first-item) (pprint rest))
(yy [1 2 3])
(defn yy[ [first-item & rest]] (pprint first-item) (pprint rest) (pprint (class rest))
)
yy
(defn yy[ [first-item & rest]] (pprint first-item) (pprint rest) (pprint (class rest)))
yy
(yy [1 2 3])
(defn yy[ [first-item & rest]] (pprint first-item) (pprint rest) (pprint (class rest)) rest)
(vector? (yy [1 2 3]))
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(use 'clojure.stacktrace) 
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(quit)
#(#{:pitch :dash} nil)
(#{:pitch :dash} nil)
(def x [1 2])
(def y [x x])
(postwalk (fn[z] (println z) z) y) 
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(def x [1 2])
(def y [x x])
(postwalk (fn[z] (println z) z) y) 
(postwalk (fn[z] (println z) (assoc z 0 (inc (first z)))) y) 
(not (false))
(not false)
(:_my_type my-node2)
(:_my_type "hi")
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(use 'clojure.stacktrace) 
(print-stack-trace *e)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(use 'clojure.stacktrace) 
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
node
(node)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer) 
(print-stack-trace *e)
(def x [:PITCH_WITH_DASHES
 {:pitch_source "S",
  :numerator 1,
  :normalized_pitch "C",
  :denominator 1,
  :column_offset 0,
  :_my_type :pitch,
  :_source "S",
  :_start_index 0}
 {:_my_type :dash, :_source "-", :_start_index 1}]
)
x
(subvec x 1)
(concat 1 [2 3])
(concat [1] [2 3])
(conj [1 2] 3)
(conj [1] [2 3])
(into [] (concat [1] [2 3]))
(subvec [1 2 3] 0)
(subvec [1 2 3] 1)
(concat [1] [2 3])
([1 2] 0)
quit
  (use 'test :reload) (ns doremi_script_clojure.test)  
quit
 (use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(my-test "S")
(run-through-parser "S")
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
 (use 'clojure.stacktrace)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(transform-parse-tree (run-through-parser txt) txt)
(pprint (my-test "S"))
 (print-stack-trace *e)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(user 'doremi_script_clojure.semantic_analyzer :reload)
(use 'doremi_script_clojure.semantic_analyzer :reload)
(pprint (my-test "S"))
exit
(:_my_type [])
(def x 9)
(case x 1 2 9 3)
(def- a 1)
(not 1)
(not nil)
(:x nil)
exit
 (:import [net/davidashen/text/Hyphenator])
 (:import [net/davidashen/text])
 (:import net/davidashen/text)
 (:import 'net/davidashen/text)
 (:import net/davidashen/text)
exit
 (use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
texhyphj
(import texhyphj)
(import 'texhyphj)
(doc import)
(import [net.davidashen/texhypj "1.0"]
(import net.davidashen/texhypj)
(import texhypj)
(use net.davidashen/texhypj)
(use 'net.davidashen/texhypj)
(net.davidashen.text.Hyphenator)
(net.davidashen.text.Hyphenator.)
(def h (net.davidashen.text.Hyphenator.))
(methods h)
(hyphenate h "hello")
(h hyphenate "hello")
(h .hyphenate "hello")
(def h net.davidashen.text.Hyphenator)
(h.hyphenate "hello")
h.hyphenate
(def h net.davidashen.text.Hyphenator)
(def h (new net.davidashen.text.Hyphenator))
(.hyphenate h "hello")
(.hyphenate h "hello" 1 1)
(.hyphenate h "hello" 0 0)
(.hyphenate h "hello")
(def h (new net.davidashen.text.Hyphenator))
(.hyphenate h "hello")
(.loadTable h (slurp "hyphen.tex"))
(.loadTable h (slurp "doremiscript.ebnf"))
(.loadTable h (slurp "./doremiscript.ebnf"))
(.loadTable h (slurp "./resources/doremiscript.ebnf"))
(.loadTable h (slurp "hyphen.txt"))
(.loadTable h (slurp "./resources/hyphen.txt"))
(slurp "./resources/hyphen.txt")
(slurp "hyphen.tex")
(slurp "./hyphen.tex")
(slurp "/hyphen.tex")
(slurp "/resources/hyphen.tex")
(slurp "./resources/hyphen.tex")
(.loadTable h (slurp "./resources/hyphen.txt"))
(.loadTable h (slurp "./resources/hyphen.tex"))
(slurp "/resources/hyphen.tex")
(slurp "/hyphen.tex")
(slurp "./hyphen.tex")
(symbol "S")
(symbol 'S')
(keyword 'S')
(keyword "S")
(split "hi")
(clojure.string/split "HI")
(clojure.string/split "HI" nil)
("Ssharp" subs "sharp" "#")
(subs "Ssharp"  "sharp" "#")
(clojure.string/replace "Ssharp" "sharp" "#")
(def sargams "S r R g G m M P d D n N Sb mb Pb Ssharp Rsharp Gsharp Psharp Dsharp Nsharp")
(map #(clojure.string/replace % "sharp" "#") sargams)
(split sargams)
(split sargams " ")
(clojure.string/split sargams " ")
(clojure.string/split sargams #" ")
exit
(dec 6)
(sub "zoo" "z" "x")
(subs "zoo" "z" "x")
(clojure.string/replace "zoo" "z" "x")
(some #(= % 1) [2 1 1])
(some #(if (= % 1) %)) [2 1 1])
(some #(if (= % 1) %) [2 1 1])
(update-in nil [:hi] "john")
(update-in nil [:hi] first)
(assoc nil [:hi] first)
(map inc 1)
(map inc [1])
(assoc nil 1 2)
(time (+ 1 1))
(def x (time (+ 1 1)))
x
 (use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(def txt "S")
(time (run-through-parser txt)
)
(map [1 2 3 4])
(array-map [1 2 3 4])
(array-map 1 2 3 4)
(map (fn[x y] (+ x y)) (array-map 1 2 3 4))
(map (fn[[x y]] (+ x y)) (array-map 1 2 3 4))
(apply array-map [1 2])
(use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_c    lojure.semantic_analyzer)
 (use 'doremi_script_clojure.semantic_analyzer :reload) (ns doremi_script_clojure.semantic_analyzer)
 (use 'clojure.stacktrace)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(use 'clojure.stacktrace)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(pst)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(print-stack-trace *e)
(def z [:ATTRIBUTE_SECTION_ITEMS "hi" "john" "author" "me"])
z
(array-map (rest z))
(apply array-map (rest z))
(map identity {1 2})
(first nil)
(:x nil)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(print-stack-trace *e)
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(print-stack-trace *e)
(use 'doremi_script_clojure.semantic_analyzer :reload) 
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(print-stack-trace *e)
(name :key)
quit
(keys {1 2})
(merge {1 2} {1 nil})
(filter (fn[[k v] ({1 2 3} k)) {1 1 2 3 5 6})
(filter (fn[[k v] (#{1 2 3} k)) {1 1 2 3 5 6})
(filter (fn[[k v] (#{1 2 3} k) {1 1 2 3 5 6})
(filter (fn[[k v]] (#{1 2 3} k)) {1 1 2 3 5 6})
(use 'doremi_script_clojure.semantic_analyzer :reload) 
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
quit
(use 'doremi_script_clojure.test :reload) (ns doremi_script_clojure.test)
(merge {1 1} {1 2})
(name :key)
exit
(def z [0 1])
(nth z 4)
(get z 4)
(def a '(1 2 3 4))
a
(rest a)
(def x {1 2})
x
(assoc x 3 4)
(assoc x [3 4])
(apply x assoc [3 4])
(first '(1 2))
(head '(1 2))
(head [1 2])
(def p {:_my_type :pitch, :fraction_array [{:numerator 1, :denominator 4}], :
pitch_source S, :normalized_pitch C, :numerator 1, :denominator 4, :octave 0, :b
eat-counter 0, :attributes [{:_my_type :begin_slur, :_source (, :_start_index 0}
], :pitch-counter 0, :column_offset 1, :_source (S, :_start_index 1, :value :S})
{:_my_type :pitch, :fraction_array [{:numerator 1, :denominator 4}], :
pitch_source R, :normalized_pitch D, :numerator 1, :denominator 4, :octave 0, :b
eat-counter 1, :pitch-counter 1, :column_offset 0, :_source R, :_start_index 2,
:value :R}
(def p {:_my_type :pitch,
 :fraction_array [{:numerator 1, :denominator 4}],
 :pitch_source "S",
 :normalized_pitch "C",
 :numerator 1,
 :denominator 4,
 :octave 0,
 :beat-counter 0,
 :attributes [{:_my_type :begin_slur, :_source "(", :_start_index 0}],
 :pitch-counter 0,
 :column_offset 1,
 :_source "(S",
 :_start_index 1,
 :value :S})
(assoc-in p [:_my_type])
(get-in p [:_my_type])
(get-in p [:attributes])
(any true [1 2])
(some true [1 2])
(some #(true) [1 2])
(some (fn[x] true) [1 2])
quit
(some #(= 1 %) [1 2 3])
(some #(if (= 1 %) %) [1 2 3])
