(defn outer [x]
  ;(println "in outer, x is " x)
  x
  )

(defn inner [x]
  (println "in inner, x is " x)
  (println "in inner, (class x) is " (class x))
  (println "in inner, (seq? x) is " (seq? x))
  (println "in inner, (map? x) is " (map? x))
  (cond
    (map? x)
    (do
      (assert (:tag x))
      (assert (:content x))
      {:tag (:tag x) :content  (walk inner outer (:content x)) }
      )
    (seq? x)
    (do
      (println "seq? case")
      (conj (walk inner outer (rest x)) (walk inner outer (first x)))
      )
    true
    x
))
