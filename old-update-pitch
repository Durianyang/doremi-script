(defn- update-sargam-pitch-node [sargam-pitch nodes]
  ;; (S  is causing problems because the column is off by 1
  ;; same with things like <foo>
  ;; perhaps have parser produce
  ;; (pitch-with-left paren (sargam-pitch "S")) and then
  ;; unwrap pitch-with-left-paren ???. Or change parser.
  ;;  (S --> left-paren S
  ;; TODO: breaks with begin/end slur
  (if false
    (do
      ;(println "update-sargam-pitch-node********")
      ;(pprint sargam-pitch)
      ;(println "nodes")
      ;(pprint nodes)
      ;(println "end nodes")
      ;(println "********")
      ))
  ;; nodes should get transformed into attributes--
  ;;attributes: 
  ;;                    [ { _my_type: 'begin_slur', source: '(' },
  ;;                     { _my_type: 'chord_symbol', source: 'F', column: 40 },
  ;;                    { _my_type: 'ending', source: '1_____', num: 1, column: 40 } ],                       
  ;; 
  (comment
  (let [
        content (rest sargam-pitch)
        mordent (last (filter #(and (vector? %) (= (first %) :MORDENT)) nodes))
        syls (filter #(and (vector? %) (= (first %) :SYLLABLE)) nodes)
        upper-upper-dots (filter #(and (vector? %) (=(first %) :UPPER_UPPER_)) nodes)
        upper-dots (filter #(and (vector? %) (=(first %) :UPPER_OCTAVE_DOT)) nodes)
        upper-upper-dots (filter #(and (vector? %) (=(first %) :UPPER_UPPER_OCTAVE_SYMBOL)) nodes)
        lower-dots (filter #(and (vector? %) (=(first %) :LOWER_OCTAVE_DOT)) nodes)
        lower-lower-dots (filter #(and (vector? %) (=(first %) :LOWER_LOWER_OCTAVE_SYMBOL)) nodes)
        chords (map second (filter #(= :CHORD (first %)) nodes))
        tala (second (last (filter #(and (vector? %) (=(first %) :TALA)) nodes)))
        ornaments (filter #(and (vector? %) (=(first %) :SARGAM_ORNAMENT)) nodes)
        octave  (+ (count upper-dots) 
                   (- (count lower-dots))
                   (* 2 (count upper-upper-dots))
                   (* -2 (count lower-lower-dots))
                   )
        ;;      sarg (first (second (second sargam-pitch)))
        ;; sarg (first (second (second sargam-pitch)))
        sarg  (some #(if (= (first %) :SARGAM_MUSICAL_CHAR) (first (second %))) (rest sargam-pitch))
        ]
    ; (pprint z)
    ;; Note that we support multiple syllables, ornaments, and chords per note. But only return the last (for now)
    ;;   (pprint "in update-sargam-pitch-node")
    ;;  (pprint "sargam-pitch is")
    ;;(println "sarg" sarg)
    (sorted-map 
      :_my_type "pitch"
      :normalized_pitch
      (sarg to-normalized-pitch)
      :attributes []
      :pitch_source (sarg sargam-pitch-to-source)
      :_source (:_source (meta sargam-pitch))
      ;; :source (sarg sargam-pitch-to-source)
      :column_offset 0
      :octave
      octave
      :numerator 1
      :denominator 1
      ;; :fraction_array  [ { :numerator , denominator: 1 } ]nil ;; TODO: review
      :syllable
      (second (last syls))
      :chord
      (last chords)
      :ornament   ;; just the pitches
      (into (vector) (rest (last ornaments)))
      :tala
      tala
      :mordent
      (second mordent)
      )))
  )
