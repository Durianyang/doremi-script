(*  EBNF grammar for doremi-script - this is for the clojure instaparse libarary *)
(* grammar for aacm/bhatkande style sargam/letter notation  *)
(* author: john rothfield 707 538-5133, cell 707 331-2700  rthfield@sonic.net *)
(* use syntax highlighting for ocaml or applescript in your text editor *)
(* vim: set filetype=ocaml *)

composition (* a musical piece *)
     (* each section is separated by one or more 'empty' lines.
      the empty line can have spaces. section doesn't include the eol.
      that allows things like "s" to parse as a composition *)
  = <empty-line*> composition-items <empty-line*> <white-space*> 



<composition-items>=
 section (<newline> <empty-line+>  section)* 

<section> = (* 3 kinds of sections: attributes, lyrics and sargam.
   typically a composition will have attributes followed by lyrics, followed
   by lines of sargam. *)
(sargam-section / attribute-section / lyrics-section) 

(* todo: add support for abc number and devanagri notations
    uppers:upper-octave-line*
    sargam:(sargam:devanagri-sargam-line / sargam:sargam-line / sargam:abc-sargam-line/ sargam:number-sargam-line)
    lowers:lower-octave-line*
    lyrics:lyrics-line?
  *)


sargam-section  
     (* a line of music, but is written over multiple physical lines. 
     there is an order. optional upper octave lines followed by main line 
      of sargam followed by optional lower octave and lyrics lines.
      usually one or two upper lines followed by mandatory sargam line followed by
      lower octave line followed by lyrics *)

(* original
   uppers:upper-octave-line*
    sargam:(sargam:devanagri-sargam-line / sargam:sargam-line / sargam:abc-sargam-line/ sargam:number-sargam-line)
    lowers:lower-octave-line*
    lyrics:lyrics-line?

*)

  =  (upper-octave-line <newline>)*  sargam-line (<newline> lower-octave-line)*
  (<newline> lyrics-line)*

sargam-line (* consists of optional line# at beginning of line, followed by 1 or
more measures followed  *) = line-number?
(* consists of optional line# at beginning of line, followed by 1 or more measures followed  *)
   <white-space?> barline? measure (barline measure)*  barline? <white-space?>



(* old
sargam-line-item  "an item in the main line"
  = x:measure /
    x:white-space /  
    x:beat-delimited / 
    x:beat-undelimited / 
    x:sargam-pitch / 
    x:rhythmical-dash / 
    x:barline / 
    x:repeat-symbol {
            x.attributes=[];
            return x;
    }
 
 *)
attribute-section (* key value pairs *)
 = attribute-section-items
<attribute-section-items> = attribute-line (<newline> attribute-line)* 

lyrics-section (* lines of lyrics *)
  = lyrics-line (<newline> lyrics-line)*

<empty-line>= white-space? newline  


(************** barlines **********************)
<barline>  (* a musical barline or repeat *)
  = 
  reverse-final-barline  |
  final-barline  |
  double-barline  |
  left-repeat  |
  right-repeat  |
  single-barline 

reverse-final-barline  (* ie [|, a reverse final barline *)
  = <'[' "|">

final-barline (* ie |], a final barline *)
  = <'|' ']'>

double-barline (* ie ||, a solid barline *)
  = <'|' '|'>

single-barline (* ie | *)
  = <'|' ! ('|' | ']' | ':')>
left-repeat (* ie |:  *)
  = <"|:">

right-repeat (* ie :| *)
  = <":|">

(**** end barline section *)

(****   pitches, sharps and flats ************)	
	
flat-or-sharp = '#' | 'b'

(*  Letters SrRgGmMPdDnN in latin script  *)
  Sb  = <"Sb">
  Ssharp =    <"S#">  
  Rsharp  =    <"R#">  
  Gsharp  =    <"G#">   
  Psharp  =    <"P#">   
  Pb   =    <"Pb">   
  Dsharp  =    <"D#">   
  Nsharp   =   < "N#">  
  Pb    =    <"Pb">   
  S  =    <"S"> ! flat-or-sharp  
  r =    <"r"> ! flat-or-sharp  
  R  =   <"R"> ! flat-or-sharp  
  g =    <"g"> ! flat-or-sharp  
  G =    <"G"> ! flat-or-sharp  
  m =    <"m"> ! flat-or-sharp  
  M =    <"M"> ! flat-or-sharp  
  P =    <"P"> ! flat-or-sharp  
  d =    <"d"> ! flat-or-sharp  
  D =    <"D"> ! flat-or-sharp  
  n =    <"n"> ! flat-or-sharp  
  N =    <"N"> ! flat-or-sharp  

<pitch>  = 
    Sb |
    Ssharp |
    Rsharp |
    Gsharp |
    Psharp |
    Pb |
    Dsharp |
    Nsharp |
    Pb |
    S |
    r |
    R |
    g |
    G |
    m |
    M |
    P |
    d |
    D |
    n |
    N 

end-slur = <')'>


<newline>= "\r\n" | "\n"
(***  end pitches *********************)
		 
space  (* space *)
  = ' '

<white-space> (* one or more spaces *)
=    #' +'   
(***** beats and measures ****)
<begin-beat-symbol>  (* symbol to use to indicate start of beat *)
  =   '<' 
<end-beat-symbol>  (* symbol to use to indicate end of beat *)
  =   '>'  

(* beats are sequences of pitches or dashes. spaces separate beats. beats can also be
delimited by angle brackets, in which case white space can be used in the beat *)
beat = beat-delimited | !begin-beat-symbol beat-undelimited 
dash =  (* ie a -, used as a rhythmical placeholder. ie s--r--g- *) 
   <'-'>

line-number (*    1)    2)     3) etc     *) 
= digits  <')'>  <white-space?>

<digits> = (* one or more digits *)  #'\d+'


repeat-symbol = <'%'>
begin-slur = <"(">
end-slur = <")">

<beat-delimited> (* ie <s r g m> . useful if lyrics wouldn't line up otherwise!. 
use srgm> or s r g m> to group pithes into a single beat. the > delimiters correspond to the lower loop in the aacm notation system *)
  = <begin-beat-symbol> beat-delimited-items <end-beat-symbol>

<beat-delimited-items> = (* inside of a delimited beat, ie <s--  r--  g-> *)
    beat-delimited-item+

<beat-delimited-item> =
    begin-slur /
    end-slur /
    pitch / 
    dash /
    <white-space>

<beat-undelimited> (* beats can be indicated by a group of pitches that consist only of pitches and dashes such as 's--r--g-'   can't contain spaces *)
  = beat-undelimited-items 
<beat-undelimited-items> = beat-undelimited-item+


<beat-undelimited-item> (* inside of a simple beat, ie s--r--g- note that undelimited beats cannot contain spaces *)
  = 
    pitch / 
    dash /
    begin-slur /
    end-slur


non-barline 
  =
    white-space /  
    beat 

<measure-items> = beat (<white-space> beat)*
measure 
  = <white-space?> measure-items <white-space?>

(* unused
unused-sargam-line-item  
an item in the main line 
  = measure /
    white-space /  
    beat-delimited / 
    beat-undelimited / 
    sargam-pitch / 
    dash / 
    barline / 
    repeat-symbol 
*)

lyrics-line (* line of syllables *)
  = <white-space?> lyrics-line-items

<lyrics-line-items> = syl (lyrics-line-item)*

<lyrics-line-item> = syl | <white-space>

(* items in lyrics line, ie a word or a syllable. ie he-llo john gives 3 items, 3 syllables *)

<syl> =  hyphenated-syl | non-hyphenated-syl
<hyphenated-syl> (* ends in a hyphen *)
  = #"[a-zA-Z'!]+-" 

<non-hyphenated-syl> (* doesn't end in hyphen  *)
  = #"[a-zA-Z'!]+" !"-"

upper-octave-line (* can put upper octave dots or semicolons for upper upper octave (. or :). also tala symbols +203   *)
= <white-space?> upper-octave-line-items

<upper-octave-line-items>= upper-octave-line-item+

ornament= undelimited-ornament | delimited-ornament

<delimited-ornament> (* in upper line <nrsns> *)
  =  <"<"> ornament-items  <">">

ornament-items = ornament-item+

<undelimited-ornament> (* in upper line nrsns *)
  = !"<" ornament-items 

<ornament-item>
  = pitch 

mordent = <"~"> 


alternate-ending-indicator 
(*   1.------- 2.--- etc. the period is optional. must have either dot or underscores. todo: accepts 1-.--- which is not exactly what i want.  *)

= #"[1-3]"  #"[\._]+" 
<upper-octave-line-item> (* things above notes, including talas, octaves,chords,
and 1st and second ending symbols. 
todo:
note that there is controversy over whether something is a chord or an
ornament! for now i've put ornaments before chords. perhaps we should have
an ornament-or-chord item and let the semantic analyzer distinguish them.
the semantic analyzer can decide whether something is an ornament or not
by looking at the column.
since ornaments are either before or after a note according to the current
scheme, there should be little overlap!!
another idea is to tag the lines as follows:

chords:
ornaments:
tala:

but that seems ugly

another idea is to have a
chord-upper-line = 3 or more chords ??? that could disambiguate it.

another idea is to use [chord-symbol] vs <ornament> to disambiguate the 2.
 *)
  = <white-space> /
 upper-octave-dot /
 tala /
	   ornament /
     chord /
 mordent /
 upper-upper-octave-symbol /
alternate-ending-indicator 
	(*
     delimited-ornament  / 
     white-space / 
     upper-octave-dot /
     alternate-ending-indicator /
     tala /
     mordent /
     upper-upper-octave-symbol /
     chord /
     ornament  
   *)
upper-octave-dot= <dot> 

dot = (*  period and asterisk are allowed *)
  #"[\.*]"

upper-upper-octave-symbol=<":">

tala (* tala markings. ie +203 for tintal. 012 for rupak *)
  = #"[+1203456]"

forward-slash-char  (* note that putting forward slash in regex doesn't seem to work *)
  = "\\"

(* chord-char  todo: review
  = char:[a-ga-gmimaiivv0-9+] / char:forward-slash-char
*)


chord = #"[a-gA-GvViI][^\s]*"

lower-octave-line (* can put lower octave dots or semicolons for lower-lower octave (. or :)   *)
  = <white-space?> lower-octave-line-items <white-space?> 

<lower-octave-line-items>= lower-octave-line-item+
<lower-octave-line-item> =  <white-space> | lower-octave-dot |
          lower-lower-octave-symbol | kommal-indicator  

lower-octave-dot= <dot>
lower-lower-octave-symbol=":"
kommal-indicator (* an underscore for flat. for the traditional bhatkande notation - devanagri, indicates a flatted note, since devanagri seems not to have lowercase *)
 = "_"


<attribute-line> (* ie author: john rothfield *)
= key <white-space?>   <":"> <white-space?> value <white-space?>

<key>= (* ie author *)  #"\w+"

<value>=  (* attribute value can have embedded spaces.  *)
(* non-space followed by (spaces | non-space)   *)
#"[^\n\r ](( *)[^\n\r ])*"


